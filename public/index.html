<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Softest Software Syllabus by Ross Chapman</title>
    <link href="/style.css" rel="stylesheet" type="text/css" media="all">
  </head>
  <body>

    <h1>A syllyabus for software developers, mostly off-center.</h1>
    By <a href="https://internetross.website">Ross Chapman</a>
    <h2>High recommends, though they hit different depending on where you're at in your career. I think each one will make you a better developer. At the very least help situate your point of view within industry discourse.  </h2>
    <p><i>(In no particular order)</i></p>

    <p>
      <img src="/reading-rainbow.png" alt="Levar Burton being weird"/>
    </p>

  test
    <dl>
      <dt>Books</dt>
      <dd><b>Dreaming In Code</a></b> by Scott Rosenberg - Analgesic <i>schadenfreude</i>. Or maybe mitfreude. Or mitgefühl. In any case, a compassionate "how the sausage is made" tale seasoned  with insightful study and surmisings of why it's so hard. Probably a more useful intro to software construction than any technical manual.</dd>
      <dd><b>Elements of Clojure</a></b> by Zachary Tellman - A compact (dense, not concise) metaphysical wander through software design.</dd>
      <dd><b>Ruby Garbage Collection in Under Two Hours</a></b> by Jemma - GREAT for beginners. Not sure a comparably concise and joyful book on the subject matter exists.</dd>
      <dd><b>Software Theory</a></b> by Federica Frabetti - Software folds in on itself. Slips definition. This is why I love it so much.</dd>
      <dd><b>Shanzai</a></b> by Byung-Chul Han - Helps shrug off the Western myth of the genius programmer; how the cultures of east asia gave us refactoring; assuages concerns about copy & paste code</dd>
      <dd><b>A City is Not a Tree</a></b> by Christopher Alexander - Composition vs inheritance drama, refutes Konmari, embracing the microbial perhaps, helps you shake off Aristotle's Great Chain of Being with a bit of overlap and powerset cladistics. Makes sure to get the 50th anniversary edition with companion essays! </dd>
      <dd><b>The Programmer's Brain</a></b> by Felienne Hermans - TODO</dd>
      <dd><b>Software Development and Reality Construction</b> by Christiane Floyd (Editor), Heinz Züellighoven (Editor), Reinhard Budde (Editor), Reinhard Keil-Slawik (Editor) - Helps orient an understanding of the software <em>discipline</em>. Probably useful to read after you've been undone by Frabetti (above). </dd>
      <dd><b>A compilation of poetry written in code (3rd Ed)</b> project of Ishac Bertran - It's open mic night. Take a breather from sweating over commercial software that enriches the ruling class.</dd>
      <dd><b>If Hemingway Wrote Javascript</b> by Angus Croll - Computer instructions would be so lush without the tyranny of arid consistency</dd>
      <dd><b>Constructing the User Interface with Statecharts</b> by Ian Horrocks - This dusty scroll is an absolute must for UI devs. The frontend is hard (sigh for your backend and system bros who gripe). Ian proves it, and we can (re)discover his solve for complex state management from 30 years ago. </dd>
      <dd><b>Grokking Simplicity</b> Eric Normand - The best "first book" on functional programming I've found.</dd>
      <dd><b>Lean Out</b> by Elissa Shevinsky - Time for active listening, my fellow men.</dd>
      <dd><b>Thinking Forth</b> by Leo Brodie - TODO</dd>
      <dd><b>Why's (Poignant) Guide to Ruby</b> by why the lucky stiff (Jonathan Gillette) - The font is too small. But this book is beastly futurist dada</dd>
      <dd><b>Practical Object-Oriented Design in Ruby</b> by Sandi Metz - Not just for cycling fans!</dd>
      <dd><b>Land of Lisp</b> by Conrad Barski - TODO</dd>
      <dd><b>Grokking Algorithms: An Illustrated Guide for Programmers and Other Curious People</b> by Aditya Bhargava - A refreshing book for programmers who were never explained the <i>when</i> and <i>why</i> of algorithms. </dd>
      <dd><b>Macintosh Human Interface Guidelines</b> by Apple Computer Inc - Some things change, some things stay the same. Like Horrocks (above), helps you relax into the consistencies of computer historicity.</dd>

      <dt>Books 2</dt>
      <p>The popular kids. In my observation, most experienced programmers will have either glanced at them or know of them and understand their influence. Unfortunately they can be a bit daunting, voluminous, borish tomes, and there's scant counsel (if any) for how to read them successfully. Yet, if you can situate, their lessons are so readily applicable to everyday practice you'll find yourself nodding along or exclaiming excitedly, "ohhhh, that's why [old so and so] suggested that in my PR"; or "ohhhh, that's why my manager talks about [xyz] all the time." Best I can advise is to start browsing from the TOC or index by topic or keyword, pick a point of entry, then go. Or try the Benjamin Franklin method (as <a href="https://www.pathsensitive.com/2018/01/the-benjamin-franklin-method-of-reading.html">explained</a> by James Koppel). In fact, today this type of reconstruction exercise is generally understood by cognitive scientists as an important strategy for memory retention, called <em>elaboration</em>: "thinking about what you want to remember, relating it to existing memories, and making the new memories fit into schemata already stored in your LTM." (p44, <em>The Programmer's Brain)</em></p>
      <dd><b>Working Effectively with Legacy Code</b> by Michael Feathers</dd>
      <dd><b>Refactoring</b> by Martin Fowler</dd>
      <dd><b>Patterns of Enterprise Application Architecture</b> by Martin Fowler</dd>
      <dd><b>Object Design: Roles, Responsibilities, and Collaborations</b> by Rebecca Wirfs-Brock and Alan McKean</dd>

      <dt>Papers/Essays</dt>
      <dd><b>Programming as Theory Building</b> by Peter Naur - A famous rebuke of the idea that programming activity reduces to code blather</dd>
      <dd><b>FAQ Sheet on Feature Interaction</b> by Pamela Zave - An elegant, concise primer on the intrinsic problem of complexity that runs through any complicated software</dd>
      <dd><b>Code is a Palimpsest</b> by Alvaro Videla  - TODO</dd>
      <dd><b>On rebooting: the unreasonable effectiveness of turning computers off and on again</b> by Keunwoo Lee - A most reasonable platitude laid bare</dd>
      <dd><b>The Seven Turrets of Babel: A Taxonomy of LangSec Errors and How to Expunge Them</b> by Falcon Darkstar Momot, Sergey Bratus, Sven M. Hallberg, Meredith L. Patterson - Empirical analysis of my fave coding anti-pattern: <em>shotgun parsing</em>. A rigorous of flank Michael Feather's "Edge-free Programming"</dd>
      <dd><b>The Ironies of Automation</b> by Lisanne Bainbridge - The 1983 paper that laughed at the idea we could code ourselves out of a job</dd>
    </dl>
  </body>
</html>
